---
description: 
globs: 
alwaysApply: false
---
# MC Shop Application Architecture

## Core Architecture Principles

### Backend: Server Actions First
- **No API Routes**: All backend logic uses Next.js server actions located in [src/server/actions/](mdc:src/server/actions)
- **Server Action Pattern**: Actions are async functions that handle form submissions and data mutations
- **"use server" Directive**: All server actions must include `"use server";` at the top to enable client component integration
- **Database Layer**: All database operations use Prisma ORM with schema at [prisma/schema.prisma](mdc:prisma/schema.prisma)
- **Authentication**: NextAuth.js configured in [src/server/auth/config.ts](mdc:src/server/auth/config.ts)
- **RCON Integration**: Minecraft server communication via [src/server/rcon.ts](mdc:src/server/rcon.ts)

### Frontend: Type-Safe React with ShadCN
- **Component Library**: Exclusively use ShadCN UI components from [src/components/ui/](mdc:src/components/ui)
- **Component Installation**: `npx shadcn@latest add [component-name]` for new components
- **Layout Structure**: Root layout in [src/app/layout.tsx](mdc:src/app/layout.tsx) with nested layouts
- **Navigation**: Centralized navigation component at [src/components/navigation.tsx](mdc:src/components/navigation.tsx)
- **Toast Notifications**: Using Sonner for user feedback
- **Form Handling**: React Hook Form with Zod validation throughout

## Application Features

### Core Systems
1. **Shop Management**: Create, edit, browse shops with item inventory
2. **Request System**: Users can create requests for items they need
3. **Offer System**: Users can make offers on requests with negotiation flow
4. **Search System**: Global search across shops, items, and players
5. **Item Management**: Comprehensive item database with image support
6. **User Authentication**: Multi-step registration with Minecraft integration
7. **Admin Tools**: Item import, testing utilities
8. **Modpack Management**: Upload, version, and distribute modpacks with download functionality

### Request & Offer Workflow
1. **Request Creation**: Users create requests for items they need
2. **Offer Submission**: Other users can make offers with price and message
3. **Offer Management**: Accept/reject/withdraw offers with status tracking
4. **Negotiation**: Accepted offers move to negotiation phase
5. **Transaction**: Final completion through Minecraft server integration

### Modpack Distribution Workflow
1. **Admin Upload**: Admins upload ZIP files with mod analysis and version tracking
2. **Mod Extraction**: Automated parsing of NeoForge/Forge metadata with asset extraction
3. **Public Browsing**: Users browse available modpacks with detailed information
4. **Download System**: Streaming downloads with progress tracking and analytics
5. **Version Management**: Support for multiple versions and latest downloads

## File Structure Patterns

### Server Actions (`src/server/actions/`)
```
actions/
â”œâ”€â”€ item-actions.ts              # Item search and management
â”œâ”€â”€ rcon-actions.ts              # Minecraft server communication
â”œâ”€â”€ registration-actions.ts      # Multi-step user registration
â”œâ”€â”€ search-actions.ts            # Global search functionality
â”œâ”€â”€ shop-items.ts               # Shop inventory management
â”œâ”€â”€ shops.ts                    # Shop CRUD operations
â”œâ”€â”€ modpacks/                   # Modpack management actions
â”‚   â”œâ”€â”€ core.ts                 # CRUD operations
â”‚   â”œâ”€â”€ upload.ts              # File upload and processing
â”‚   â”œâ”€â”€ download.ts            # Download generation and analytics
â”‚   â””â”€â”€ index.ts               # Action exports
â””â”€â”€ requests/                   # Request system actions
    â”œâ”€â”€ create-request.ts       # Request creation
    â”œâ”€â”€ update-request.ts       # Request updates
    â”œâ”€â”€ delete-request.ts       # Request deletion
    â”œâ”€â”€ get-requests.ts         # Request fetching
    â”œâ”€â”€ create-offer.ts         # Offer creation
    â”œâ”€â”€ update-offer.ts         # Offer status management
    â”œâ”€â”€ get-offers.ts           # Offer fetching
    â””â”€â”€ index.ts               # Action exports
```

### Component Structure (`src/components/`)
```
components/
â”œâ”€â”€ ui/                         # ShadCN UI components
â”‚   â”œâ”€â”€ danger-zone.tsx         # Destructive action component (NEW)
â”‚   â”œâ”€â”€ page-container.tsx      # Layout wrapper component
â”‚   â”œâ”€â”€ page-header.tsx         # Standard page headers
â”‚   â””â”€â”€ form-page-header.tsx    # Form page headers with back button
â”œâ”€â”€ auth/                       # Authentication components
â”œâ”€â”€ navigation.tsx              # Main navigation
â”œâ”€â”€ items/                      # Item-related components
â”œâ”€â”€ shops/                      # Shop management components
â”œâ”€â”€ modpacks/                   # Modpack management components
â”‚   â”œâ”€â”€ download-modal.tsx      # Download progress modal (NEW)
â”‚   â”œâ”€â”€ download-latest-button.tsx # Latest version download (NEW)
â”‚   â””â”€â”€ ModpackSidebar.tsx      # Modpack detail sidebar
â”œâ”€â”€ requests/                   # Request system components
â”‚   â”œâ”€â”€ request-details.tsx     # Request detail view
â”‚   â”œâ”€â”€ offer-form.tsx          # Offer creation form
â”‚   â”œâ”€â”€ offer-list.tsx          # Offer display and management
â”‚   â””â”€â”€ index.ts               # Component exports
â””â”€â”€ search/                     # Search functionality
    â”œâ”€â”€ global-search-bar.tsx   # Main search interface
    â”œâ”€â”€ search-item-result.tsx  # Search result display
    â””â”€â”€ index.ts               # Search exports
```

### Validation Schemas (`src/lib/validations/`)
```
validations/
â”œâ”€â”€ auth.ts      # Authentication and registration schemas
â”œâ”€â”€ request.ts   # Request and offer validation schemas
â”œâ”€â”€ search.ts    # Search parameter validation
â”œâ”€â”€ shop.ts      # Shop and shop item validation schemas
â””â”€â”€ modpack.ts   # Modpack upload and management schemas (NEW)
```

### Types (`src/lib/types/`)
```
types/
â”œâ”€â”€ auth.ts      # Authentication-related types
â”œâ”€â”€ request.ts   # Request and offer types with database relations
â”œâ”€â”€ search.ts    # Search result and parameter types
â””â”€â”€ shop.ts      # Shop management types
```

### Hooks (`src/hooks/` & `src/lib/hooks/`)
```
hooks/
â”œâ”€â”€ use-registration.ts         # Multi-step registration flow
â”œâ”€â”€ use-global-search.ts        # Global search functionality
â”œâ”€â”€ use-image-fallback.ts       # Image loading with fallbacks
â”œâ”€â”€ use-search-keyboard.ts      # Keyboard navigation for search
â””â”€â”€ lib/hooks/
    â”œâ”€â”€ use-request-data.ts     # Request data management
    â”œâ”€â”€ use-request-form.ts     # Request form handling
    â””â”€â”€ use-shop-management.ts  # Shop CRUD operations
```

### Pages (`src/app/`)
```
app/
â”œâ”€â”€ page.tsx                    # Home page
â”œâ”€â”€ layout.tsx                  # Root layout
â”œâ”€â”€ auth/                       # Authentication pages
â”‚   â”œâ”€â”€ login/page.tsx         # Login page
â”‚   â”œâ”€â”€ register/page.tsx      # Registration page
â”‚   â””â”€â”€ error/page.tsx         # Auth error handling
â”œâ”€â”€ shops/                      # Shop management
â”‚   â”œâ”€â”€ page.tsx              # Shop listing
â”‚   â”œâ”€â”€ browse/page.tsx       # Public shop browsing
â”‚   â”œâ”€â”€ new/page.tsx          # Shop creation
â”‚   â””â”€â”€ [id]/                 # Individual shop pages
â”œâ”€â”€ items/page.tsx             # Item management
â”œâ”€â”€ modpacks/                  # Modpack system (NEW)
â”‚   â”œâ”€â”€ page.tsx              # Public modpack listing
â”‚   â””â”€â”€ [id]/page.tsx         # Modpack details
â”œâ”€â”€ requests/                  # Request system
â”‚   â”œâ”€â”€ page.tsx              # Request listing
â”‚   â”œâ”€â”€ new/page.tsx          # Request creation
â”‚   â””â”€â”€ [id]/                 # Individual request pages
â”‚       â”œâ”€â”€ page.tsx          # Request details with offers
â”‚       â””â”€â”€ edit/page.tsx     # Request editing
â””â”€â”€ admin/                     # Administrative functions
    â”œâ”€â”€ items/                # Item management tools
    â””â”€â”€ modpacks/             # Modpack administration (NEW)
        â”œâ”€â”€ page.tsx          # Admin modpack dashboard
        â”œâ”€â”€ upload/page.tsx   # Modpack upload interface
        â””â”€â”€ [id]/edit/page.tsx # Modpack editing
```

### API Routes (`src/app/api/`)
```
api/
â”œâ”€â”€ auth/[...nextauth]/route.ts    # Authentication endpoints
â”œâ”€â”€ minecraft/uuid/route.ts        # Minecraft UUID validation
â””â”€â”€ modpacks/                      # Modpack download endpoints (NEW)
    â”œâ”€â”€ [id]/download/route.ts     # Download specific version
    â””â”€â”€ latest/[name]/download/route.ts # Download latest version
```

## Server Action Patterns

### Standard Action Structure with "use server"
```typescript
"use server";

import { auth } from "~/server/auth";
import { db } from "~/server/db";
import { actionSchema } from "~/lib/validations/example";

export async function exampleAction(formData: FormData) {
  // 1. Validate input
  const validatedFields = actionSchema.safeParse({
    field: formData.get('field')
  });
  
  if (!validatedFields.success) {
    return { success: false, error: 'Invalid input' };
  }
  
  // 2. Check authentication
  const session = await auth();
  if (!session?.user) {
    return { success: false, error: 'Unauthorized' };
  }
  
  // 3. Database operation
  try {
    const result = await db.example.create({
      data: validatedFields.data
    });
    return { success: true, data: result };
  } catch (error) {
    return { success: false, error: 'Database error' };
  }
}
```

### Client-Server Component Integration
```typescript
// Server Component (Page)
import { exampleAction } from "~/server/actions/example";

export default function ExamplePage() {
  return (
    <ClientComponent exampleAction={exampleAction} />
  );
}

// Client Component
interface Props {
  exampleAction: (formData: FormData) => Promise<ActionResult>;
}

export function ClientComponent({ exampleAction }: Props) {
  // Use server action as prop
}
```

### Download Actions with Streaming
```typescript
"use server";

import JSZip from "jszip";
import { Readable } from "stream";

export async function downloadModpack(modpackId: string) {
  // 1. Validate modpack and permissions
  const modpack = await validateModpackAccess(modpackId);
  
  // 2. Extract mods from original ZIP
  const originalBuffer = await fs.readFile(modpack.filePath);
  const originalZip = await JSZip.loadAsync(originalBuffer);
  
  // 3. Create new ZIP with only mods folder
  const newZip = new JSZip();
  await extractModsFolder(originalZip, newZip);
  
  // 4. Track analytics
  await recordDownload(modpackId, session.user.id);
  
  // 5. Return buffer for streaming
  return await newZip.generateAsync({ type: "nodebuffer" });
}
```

## Database Schema Patterns

### Core Models
- **User**: Authentication with Minecraft UUID integration
- **Shop**: User-owned shops with location and description
- **ShopItem**: Items available in shops with pricing
- **Item**: Master item database with image paths
- **Request**: User requests for items with status tracking
- **RequestOffer**: Offers made on requests with negotiation flow
- **RequestNegotiation**: Accepted offers in negotiation phase
- **Modpack**: Versioned modpack files with metadata (NEW)
- **Mod**: Individual mod information extracted from modpacks (NEW)
- **ModpackDownload**: Download analytics and tracking (NEW)

### Relationship Patterns
```prisma
// User owns multiple shops and requests
User {
  shops     Shop[]
  requests  Request[]
  offers    RequestOffer[]
  modpacks  Modpack[]         // NEW: Admin-created modpacks
  downloads ModpackDownload[] // NEW: Download tracking
}

// Shop contains multiple items
Shop {
  items     ShopItem[]
  owner     User
}

// Request can have multiple offers
Request {
  offers       RequestOffer[]
  negotiations RequestNegotiation[]
  requester    User
}

// Modpack contains multiple mods (NEW)
Modpack {
  mods         Mod[]
  downloads    ModpackDownload[]
  createdBy    User
}
```

## UI Component Patterns

### DangerZone Component for Destructive Actions
**Location**: [src/components/ui/danger-zone.tsx](mdc:src/components/ui/danger-zone.tsx)

**Purpose**: Standardized component for all destructive actions (delete, remove, cancel) across the application.

**Features**:
- Red-themed warning design with danger icon
- Customizable title, description, and button text
- Built-in confirmation dialog with double-check
- Loading states and error handling
- Consistent spacing and typography

**Usage Pattern**:
```typescript
import { DangerZone } from "~/components/ui/danger-zone";

// In any edit/management page
<DangerZone
  title="Delete Shop"
  description="This will permanently delete the shop and all its items. This action cannot be undone."
  buttonText="Delete Shop"
  onConfirm={async () => {
    const result = await deleteShopAction(shopId);
    if (result.success) {
      router.push('/shops');
    }
  }}
/>
```

**Implementations**:
- Shop deletion in [src/app/shops/[id]/edit/page.tsx](mdc:src/app/shops/[id]/edit/page.tsx)
- Shop item removal in [src/app/shops/[id]/items/[itemId]/edit/page.tsx](mdc:src/app/shops/[id]/items/[itemId]/edit/page.tsx)
- Request deletion in [src/app/requests/[id]/edit/page.tsx](mdc:src/app/requests/[id]/edit/page.tsx)
- Modpack deletion in [src/app/admin/modpacks/[id]/edit/edit-form.tsx](mdc:src/app/admin/modpacks/[id]/edit/edit-form.tsx)

### Download Modal with Progress Tracking
**Location**: [src/components/modpacks/download-modal.tsx](mdc:src/components/modpacks/download-modal.tsx)

**Purpose**: Provides visual feedback during long-running modpack downloads with fake progress animation.

**Features**:
- Multi-state interface: Idle, Downloading, Success, Error
- Smooth progress animation during server processing
- Real-time file size and progress display
- Toast notifications for completion/errors
- Automatic cleanup and modal management

**Usage Pattern**:
```typescript
import { DownloadModal } from "~/components/modpacks/download-modal";

const [isModalOpen, setIsModalOpen] = useState(false);

// Trigger from button click
<Button onClick={() => setIsModalOpen(true)}>
  Download Modpack
</Button>

<DownloadModal
  isOpen={isModalOpen}
  onOpenChange={setIsModalOpen}
  modpackId={modpack.id}
  modpackName={modpack.name}
  version={modpack.version}
  fileSize={modpack.fileSize}
/>
```

### Conditional Download Availability
**Pattern**: Hide download functionality for inactive/unavailable content

**Implementation**:
```typescript
// In ModpackSidebar component
{modpack.isActive ? (
  <Button onClick={() => setIsDownloadModalOpen(true)}>
    Download v{modpack.version}
  </Button>
) : (
  <Button disabled variant="secondary">
    Download Unavailable (Inactive)
  </Button>
)}
```

## Search System Architecture

### Global Search Features
- **Unified Search**: Single interface for shops, items, and players
- **Keyboard Navigation**: Arrow keys and enter for navigation
- **Real-time Results**: Debounced search with instant feedback
- **Result Categorization**: Grouped results by type
- **Navigation Integration**: Search results link to relevant pages

### Search Implementation
```typescript
// Search hook with debouncing
const { results, isLoading } = useGlobalSearch(query, {
  debounceMs: 300,
  minQueryLength: 2
});

// Search action with multiple result types
export async function unifiedSearch(query: string) {
  const [shops, items, players] = await Promise.all([
    searchShops(query),
    searchItems(query),
    searchPlayers(query)
  ]);
  
  return { shops, items, players };
}
```

## Request & Offer System Patterns

### Request Lifecycle
1. **OPEN**: Accepting offers
2. **IN_NEGOTIATION**: Offer accepted, negotiating details
3. **COMPLETED**: Transaction finished
4. **CANCELLED**: Request cancelled by owner

### Offer Management
```typescript
// Offer creation with validation
export async function createOffer(formData: FormData) {
  // Prevent self-offers and duplicate offers
  // Validate request is still open
  // Create offer with PENDING status
}

// Offer status updates with transactions
export async function updateOffer(formData: FormData) {
  await db.$transaction(async (tx) => {
    // Update offer status
    // If accepted: reject other offers, create negotiation
    // Update request status accordingly
  });
}
```

## Image Management System

### Item Images
- **Multiple Resource Packs**: Default and Sphax texture support
- **Fallback System**: Graceful degradation to default images
- **Dynamic Loading**: Images loaded based on user preference
- **Path Structure**: `public/items/{pack}/{namespace}__{item}.png`

### Modpack Assets
- **Logo Extraction**: Automatic extraction from JAR files
- **Organized Storage**: `public/modpacks/logos/` for web-accessible logos
- **Fallback Handling**: Default icons for mods without logos
- **Optimized Loading**: Proper image optimization and caching

### Image Utilities
```typescript
// Image path resolution with fallbacks
export function getItemImagePath(
  itemId: string,
  resourcePack: 'default' | 'sphax' = 'default'
): string {
  // Handle namespace and item ID parsing
  // Return appropriate image path with fallbacks
}
```

## Form Patterns with React Hook Form

### Standard Form Setup
```typescript
const form = useForm<SchemaType>({
  resolver: zodResolver(validationSchema),
  defaultValues: { /* defaults */ }
});

const onSubmit = async (data: SchemaType) => {
  const formData = new FormData();
  Object.entries(data).forEach(([key, value]) => {
    formData.append(key, value.toString());
  });
  
  const result = await serverAction(formData);
  
  if (result.success) {
    toast.success("Success message");
  } else {
    toast.error(result.error);
  }
};
```

## Development Best Practices

### Code Organization
1. **Server Actions**: Always include `"use server"` directive
2. **Component Props**: Pass server actions as props to client components
3. **Type Safety**: Full TypeScript coverage with proper type definitions
4. **Validation**: Zod schemas for both client and server validation
5. **Error Handling**: Consistent error response patterns
6. **Loading States**: Proper loading feedback in all interactions

### Database Best Practices
1. **Transactions**: Use Prisma transactions for complex operations
2. **Relations**: Leverage Prisma's relation system for data fetching
3. **Migrations**: Always test migrations in development first
4. **Indexing**: Proper database indexes for search performance

### UI/UX Patterns
1. **Toast Notifications**: Consistent feedback using Sonner
2. **Loading States**: Skeleton loaders and disabled states
3. **Form Validation**: Real-time validation with helpful error messages
4. **Responsive Design**: Mobile-first approach with Tailwind CSS
5. **Accessibility**: Proper ARIA labels and keyboard navigation
6. **Destructive Actions**: Always use DangerZone component for delete operations
7. **Long Operations**: Provide progress feedback with modals or progress bars
8. **Conditional UI**: Hide unavailable actions (e.g., download inactive content)

## Adding New Features

### Feature Development Checklist
1. **Database Schema**: Update [prisma/schema.prisma](mdc:prisma/schema.prisma) if needed
2. **Types**: Create TypeScript interfaces in [src/lib/types/](mdc:src/lib/types)
3. **Validation**: Add Zod schemas in [src/lib/validations/](mdc:src/lib/validations)
4. **Server Actions**: Implement with `"use server"` in [src/server/actions/](mdc:src/server/actions)
5. **Components**: Build UI using ShadCN components
6. **Pages**: Create routes in [src/app/](mdc:src/app)
7. **Hooks**: Custom hooks for complex state management
8. **Testing**: Ensure proper error handling and edge cases

### Integration Patterns
- **Authentication**: Always check user sessions in server actions
- **Permissions**: Validate user permissions for data access
- **Error Boundaries**: Implement proper error handling at component level
- **SEO**: Use proper metadata and structured data where applicable

### Layout Containers & Headers

- **PageContainer** ([page-container.tsx](mdc:src/components/ui/page-container.tsx))
  - Reusable wrapper that enforces a consistent max-width and horizontal padding for all pages.
  - Size variants (use the smallest that fits the page):
    | Size   | Tailwind max-width |
    |--------|--------------------|
    | `small`  | `max-w-lg`  (auth forms) |
    | `medium` | `max-w-2xl` (most create / edit forms) |
    | `large`  | `max-w-5xl` (detail pages) |
    | `full`   | `max-w-7xl` (listing / overview pages â€“ default) |
  - Always import and wrap page content:  
    ```tsx
    import { PageContainer } from "~/components/ui/page-container";
    
    export default function ExamplePage() {
      return (
        <PageContainer size="medium">
          {/* content */}
        </PageContainer>
      );
    }
    ```

- **NavigationContainer** ([navigation-container.tsx](mdc:src/components/ui/navigation-container.tsx))
  - Identical padding/width rules as `PageContainer size="full"` but used **only** inside `navigation.tsx` so the navbar aligns perfectly with page content.

- **PageHeader** ([page-header.tsx](mdc:src/components/ui/page-header.tsx))
  - Standard headline/description bar with an *icon*, *title*, *description*, and optional *actions* slot.
  - Use on listing / overview pages.

- **FormPageHeader** ([form-page-header.tsx](mdc:src/components/ui/form-page-header.tsx))
  - Variant of `PageHeader` for create / edit forms.
  - Adds a **Back** button and optional status indicator while keeping the same alignment rules.

> ðŸ’¡ **Rule of thumb**: Every top-level page component should start with `PageContainer` and a suitable `PageHeader` / `FormPageHeader` so that navigation, headlines, and content all share the same vertical grid.

### Destructive Action Guidelines

**Always use DangerZone component** for any destructive operations:

1. **Delete Operations**: Shop deletion, item removal, request cancellation
2. **Irreversible Actions**: Account deactivation, data purging
3. **State Changes**: Moving from active to inactive states that affect user access

**DangerZone Implementation Pattern**:
```tsx
// Place DangerZone in a separate section at bottom of edit forms
<div className="mt-8 pt-8 border-t">
  <DangerZone
    title="Delete [Entity]"
    description="Specific description of what will be permanently lost"
    buttonText="Delete [Entity]"
    onConfirm={handleDelete}
  />
</div>
```

**Don't use DangerZone for**:
- Reversible actions (archiving, hiding)
- State changes that can be undone
- Actions that only affect current user's view
